# 06. 스칼라서브쿼리를이용한조인



## 1) 스칼라 서브쿼리

- 스칼라 서브쿼리 : 함수처럼 한 레코드당 정확히 하나의 값만을 리턴하는 서브쿼리를 '스칼라 서브쿼리'라고 한다.(select-list)
- 스칼라 서브쿼리의 테이블은 NL 조인에서 Inner 테이블의 역할을 수행하고 Driving 테이블로부터 조인 조건을 상수로 제공 받는다.



#### 스칼라 서브 쿼리

```sql
select /*+ gather_plan_statistics */ empno, ename, sal, hiredate
     , (select d.dname from dept d where d.deptno = e.deptno ) dname
from emp e
where sal >= 2000;

select * from table( dbms_xplan.display_cursor( null, null, 'ALLSTATS LAST'));
-------------------------------------------------------------------------------------------------
| Id  | Operation                   | Name    | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------------------
|   1 |  TABLE ACCESS BY INDEX ROWID| DEPT    |      3 |      1 |      3 |00:00:00.01 |       5 |
|*  2 |   INDEX UNIQUE SCAN         | PK_DEPT |      3 |      1 |      3 |00:00:00.01 |       2 |
|*  3 |  TABLE ACCESS FULL          | EMP     |      1 |     11 |      6 |00:00:00.01 |       8 |
-------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("D"."DEPTNO"=:B1)
   3 - filter("SAL">=2000)
```



#### Outer Join

```sql
select /*+ gather_plan_statistics ordered use_nl(d)*/
       e.empno, e.ename, e.sal, e.hiredate, d.dname
  from emp e, dept d
 where d.deptno(+) = e.deptno
   and e.sal >= 2000;


select * from table( dbms_xplan.display_cursor( null, null, 'ALLSTATS LAST'));
--------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name    | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
--------------------------------------------------------------------------------------------------
|   1 |  NESTED LOOPS OUTER          |         |      1 |     11 |      6 |00:00:00.01 |      16 |
|*  2 |   TABLE ACCESS FULL          | EMP     |      1 |     11 |      6 |00:00:00.01 |       8 |
|   3 |   TABLE ACCESS BY INDEX ROWID| DEPT    |      6 |      1 |      6 |00:00:00.01 |       8 |
|*  4 |    INDEX UNIQUE SCAN         | PK_DEPT |      6 |      1 |      6 |00:00:00.01 |       2 |
--------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter("E"."SAL">=2000)
   4 - access("D"."DEPTNO"="E"."DEPTNO")
```

- 위에서 예시한 쿼리는 결과만 같은 것이 아니라 조인을 수행하는 처리 경로도 동일한데, NL 방식으로 수행되도록 힌트를 사용했기 때문임



## 2) 스칼라 서브쿼리의 캐싱 효과

- 오라클은 스칼라 서브 쿼리 수행 회수를 최소화 하려고 그 입력 값과 출력 값을 내부 캐시(Query Execution Cache)에 저장해 둔다.
- 스칼라 서브쿼리가 수행될 때면 일단 '입력 값'을 캐시에서 찾아 보고 거기 있으면 저장된 '출력 값'을 리턴한다.
- 캐시에서 찾지 못할 때만 쿼리를 수행하며, 결과는 버리지 않고 캐시에 저장해둔다.



#### 스칼라 서브 쿼리 케시 알고리즘

```sql
select empno, ename, sal, hiredate
     , (select d.dname        -- 출력값 : d.dname
          from dept d 
where d.deptno = e.empno   -- 입력값 : e.empno
       )
from emp e
where sal >= 2000
```



##### TEST 준비 스크립트

```sql
CREATE TABLE T_code AS
SELECT ROWNUM code, CHR(ROWNUM + 64) NAME FROM DUAL
CONNECT BY LEVEL <= 1000

CREATE INDEX IDX_T_code_PK ON T_code(code,NAME);

ALTER TABLE T_code ADD CONSTRAINT IDX_T_code_PK PRIMARY KEY(code);

CREATE TABLE T AS
SELECT ROWNUM NO, CEIL(ROWNUM/1000) code  FROM DUAL
CONNECT BY LEVEL <= 1000000;

CREATE INDEX IDX_T_01 ON T( code);

EXEC DBMS_STATS.GATHER_TABLE_STATS(USER, 'T');

EXEC DBMS_STATS.GATHER_TABLE_STATS(USER, 'T_code');

CREATE or REPLACE FUNCTION GET_NAME(IN_code INT)
RETURN VARCHAR
IS
RET_NAME T_code.NAME%TYPE;
BEGIN
  SELECT NAME
    INTO RET_NAME
    FROM T_code WHERE code = IN_code;
  RETURN RET_NAME;
END;
/
```



#### 일반 Function

```sql
SELECT /*+ gather_plan_statistics*/ COUNT(T)
FROM (
SELECT GET_NAME(code) AS T
FROM T)
;

  COUNT(T)
----------
   1000000

select * from table( dbms_xplan.display_cursor( null, null, 'ALLSTATS LAST'));

-------------------------------------------------------------------------------------
| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------
|   1 |  SORT AGGREGATE    |      |      1 |      1 |      1 |00:00:17.42 |    2003K|
|   2 |   TABLE ACCESS FULL| T    |      1 |    994K|   1000K|00:00:00.01 |    1925 |
-------------------------------------------------------------------------------------
```



#### 스칼라 서브 쿼리 사용한 펑션

```
SELECT /*+ gather_plan_statistics*/COUNT(T)
FROM (
	SELECT (SELECT GET_NAME(code) FROM DUAL) AS T
FROM T)
;

  COUNT(T)
----------
   1000000

select * from table( dbms_xplan.display_cursor( null, null, 'ALLSTATS LAST'));

-------------------------------------------------------------------------------------
| Id  | Operation          | Name | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------
|   1 |  FAST DUAL         |      |   1000 |      1 |   1000 |00:00:00.01 |       0 |
|   2 |  SORT AGGREGATE    |      |      1 |      1 |      1 |00:00:00.18 |    3927 |
|   3 |   TABLE ACCESS FULL| T    |      1 |    994K|   1000K|00:00:00.01 |    1925 |
-------------------------------------------------------------------------------------
```

- 입력값과 출력 값을 빠르게 저장하고 찾기 위해 오라클은 해싱 알고리즘을 사용한다.
- '비용기반의 오라클 원리'저자 조나단 루이스 설명에 의하면 8i, 9i에서는 256개 엔트리를 캐싱하고
- 10에서는 입력과 출력값 크기, `_query_execution_cach_max_size` 파라미터에 의해 캐시 사이즈가 결정된다고 한다.
- 해시 충돌이 발생했을 때 기존 엔트리를 밀어내고 새로 수행한 입력 값과 출력 값으로 대체할 것 같지만, 오라클은 기존 캐시 엔트리를 그대로 둔 채 스칼라 서브 쿼리만 한 번 더 수행하고 만다.따라서 해시 충돌이 발생한 입력 값이 반복적으로 입력되면 스칼라 서브쿼리도 반복 수행된다.



#### 결론

- 스칼라 서브쿼리의 캐싱 효과는 입력 값의 종류가 소수여서 해시 충돌 가능성이 적은 때라야 효과가 있으며, 반대의 경우라며 캐시를 확인하는 비용 때문에 오히려 성능은 저하되고 CPU 사용률만 높게 만든다.
- 게다가 스칼라 서브쿼리를 사용하면 NL조인에서 Inner 쪽인덱스와 테이블에 나타나는 버퍼 Pinning 효과도 사라진다는 사실을 기억할 필요가 있다.