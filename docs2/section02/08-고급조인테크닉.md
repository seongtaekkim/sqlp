# 08. 고급조인테크닉





## 1) 누적 매출 구하기

```sql
create table month_sales
as
select deptno as "지점"
        , row_number() over (partition by deptno order by empno) as "판매월"
        , round(dbms_random.value(500, 1000)) as "매출"
    from emp
    order by deptno
;


select *
from month_sales
;

      지점     판매월       매출
---------- ---------- ----------
        10          1        895
        10          2        560
        10          3        551
        20          1        948
        20          2        992
        20          3        852
        20          4        950
        20          5        836
        30          1        871
        30          2        681
        30          3        993
        30          4        518
        30          5        551
        30          6        846
```



- 오라클 8i부터 제공되기 시작한 분석함수(Analytic Function)를 이용하면 아래와 같이 간단하게 각 지점별로 판매월과 함께 증가하는 누적매출(running total) 결과를 얻을 수 있다.

```sql
select "지점", "판매월", "매출"
      , sum("매출") over (partition by "지점" order by "판매월"
                           range between unbounded preceding and current row
                         ) as "누적매출"
from month_sales
;

      지점     판매월       매출   누적매출
---------- ---------- ---------- ----------
        10          1        895        895
        10          2        560       1455
        10          3        551       2006
        20          1        948        948
        20          2        992       1940
        20          3        852       2792
        20          4        950       3742
        20          5        836       4578
        30          1        871        871
        30          2        681       1552
        30          3        993       2545
        30          4        518       3063
        30          5        551       3614
        30          6        846       4460
```



- 아래는 부등호 조인을 통해 지점별 누적매출을 구하는 방법을 예시

```sql
select t1."지점", t1."판매월", min(t1."매출") as 매출, sum(t2."매출") as 누적매출
      from   month_sales t1, month_sales t2
      where  t2."지점" = t1."지점"
      and    t2."판매월" <= t1.판매월
      group by t1."지점", t1."판매월"
      order by t1."지점", t1."판매월"
;

      지점     판매월       매출   누적매출
---------- ---------- ---------- ----------
        10          1        895        895
        10          2        560       1455
        10          3        551       2006
        20          1        948        948
        20          2        992       1940
        20          3        852       2792
        20          4        950       3742
        20          5        836       4578
        30          1        871        871
        30          2        681       1552
        30          3        993       2545
        30          4        518       3063
        30          5        551       3614
        30          6        846       4460
```







## 2) 선분이력 끊기

- 선분이력 레코드를 가공해야 할 때가 있는데, 월말 기준으로 선분을 끊는 경우를 살펴보자.
- 본론으로 들어가기에 앞서, 두 선분이 겹치는 구간에 대한 시작일자 및 종료일자 선택 규칙에 대해 살펴보자.
- 시간을 나타내는 두 개의 선분이 서로 겹치는 모습을 표현하면, 아래의 그림처럼 네 가지 패턴이 있다.



![스크린샷 2024-04-22 오전 10.40.46](../../img/141.png)



![스크린샷 2024-04-22 오전 10.40.59](../../img/142.png)







![스크린샷 2024-04-22 오전 10.41.05](../../img/143.png)



- '월도'와 '선분이력' 테이블 생성

```sql
create table 월도(기준월, 시작일자, 종료일자)
as
select '200906', '20090601', '20090630' from dual union all
select '200907', '20090701', '20090731' from dual union all
select '200908', '20090801', '20090831' from dual union all
select '200909', '20090901', '20090930' from dual union all
select '200910', '20091001', '20091030' from dual
;

create table 선분이력 (상품번호, 시작일자, 종료일자, 데이터)
as
select 'a', '20090713', '20090808', 'a1' from dual union all
select 'a', '20090809', '20090820', 'a2' from dual union all
select 'a', '20090821', '20091007', 'a3' from dual
;

select a.기준월, b.시작일자, b.종료일자, b.상품번호, b.데이터
    from 월도 a, 선분이력 b
   where b.시작일자 <= a.종료일자
     and b.종료일자 >= a.시작일자
   order by  a.기준월, b.시작일자
;

기준월       시작일자         종료일자         상품번호  데이터
------------ ---------------- --------- --------- ----
200907       20090713         20090808       A     A1    ----- 5 -> 8
200908       20090713         20090808       A     A1    ----- 5 -> 9
200908       20090809         20090820       A     A2    ----- 6 -> 10
200908       20090821         20091007       A     A3    ----- 7 -> 11
200909       20090821         20091007       A     A3    ----- 7 -> 12
200910       20090821         20091007       A     A3    ----- 7 -> 13
```

- 5번 선분은 8,9 두 선분으로 복제되었고, 7번 선분은 11,12,13 세 선분으로 복제되었다.
- 7번 선분을 기준으로 설명하면, 시작일자가 자신의 종료일자보다 작은 월도(b.종료일자 >= a.시작일자)는 1,2,3,4번이 모두 해당되고, 종료일자가 자신의 시작일자보다 큰 월도(b.시작일자 <= a.종료일자)는 2,3,4번이다.
- 따라서 두 조건을 모두 만족하는 월도는 2,3,4번이므로 7번 선분은 세개로 복제가 이루어진다.
- 선분이력이 여러 개 생기더라도 기준월은 각각 다른 값을 가진다는 점에 주목하기 바란다.

- 여섯 개 선분의 시작일자와 종료일자를 구하는 것이 숙제인데, 이를 위해 8~13번 선분을 그림 2-24에 예시한 스타일로 분류하면 다음과 같다.

- 변환된 8번과 11번 선분은 스타일 a에 속한다.
- 변환된 9번과 13번 선분은 스타일 b에 속한다.
- 변환된 10번 선분은 스타일 c에 속한다.
- 변환된 12번 선분은 스타일 d에 속한다.

- a,b,c,d스타일별로 특징을 정리했던 표를 이용하면 조금 전 쿼리에서 얻은 여섯 개 선분의 시작일자와 종료일자를 쉽게 구할 수 있다.
- 아래 쿼리의 수행 결과를 보면, 그림 2-25 하단에 있는 '변환된 선분이력'과 똑같은 결과집합인 것을 알 수 있다.

```sql
SELECT 상품번호
        ,case when lst = 시작일자1 and gst = 종료일자2 then 시작일자2   -- 스타일a
              when lst = 시작일자2 and gst = 종료일자1 then 시작일자1   -- 스타일b
              when lst = 시작일자1 and gst = 종료일자1 then 시작일자2   -- 스타일c
              when lst = 시작일자2 and gst = 종료일자2 then 시작일자2   -- 스타일d
         end 시작일자
        ,case when lst = 시작일자1 and gst = 종료일자2 then 종료일자2   -- 스타일a
              when lst = 시작일자2 and gst = 종료일자1 then 종료일자1   -- 스타일b
              when lst = 시작일자1 and gst = 종료일자1 then 종료일자2   -- 스타일c
              when lst = 시작일자2 and gst = 종료일자2 then 종료일자2   -- 스타일d
         end 종료일자
        ,데이터
    FROM (
            SELECT b.상품번호,b.데이터,a.기준월
                   ,a.시작일자 시작일자1,b.시작일자 시작일자2
                   ,a.종료일자 종료일자1,b.종료일자 종료일자2
                   ,least(a.시작일자,a.종료일자,b.시작일자,b.종료일자) lst
                   ,greatest(a.시작일자,a.종료일자,b.시작일자,b.종료일자) gst
              FROM 월도 a, 선분이력 b
             WHERE b.시작일자 <= a.종료일자
               AND b.종료일자 >= a.시작일자
          )
;

상품번호   시작일자         종료일자         데이터
--------- ---------- -------------- ----------
    A        2009/07/13         2009/07/31         A1
    A        2009/08/01         2009/08/08         A1
    A        2009/08/09         2009/08/20         A2
    A        2009/08/21         2009/08/31         A3
    A        2009/09/01         2009/09/30         A3
    A        2009/10/01         2009/10/07         A3
```







## 3) 데이터 복제를 통한 소계 구하기

- 쿼리를 작성하다 보면 데이터 복제 기법을 활용해야 할 때가 많다. 데이터복제를 위해 일부러 카티션 곱(Cartesian Product)을 발생시켜 복제하기도 한다.
- 전통적으로 많이 쓰던 방식은 복제용 테이블(copy_t)을 미리 만들어두고 이를 활용하는 것이다.

```sql
create table copy_t (no number, no2 varchar2(2));

Table created.

insert into copy_t
select rownum, lpad(rownum,2,'0') from all_tables where rownum<=31;

31 rows created.

commit;

Commit complete.

alter table copy_t add constraint copy_t_pk primary key(no);

Table altered.

create unique index copy_t_no2_idx on copy_t(no2);

Index created.

-- 아래 쿼리를 실행하면 emp 테이블에 있는 14개의 레코드가 3개씩 총 42개로 복제된다.
select *
   from emp a, copy_t b
   where b.no<=3
;


     EMPNO ENAME      JOB              MGR HIREDATE            SAL       COMM     DEPTNO       NO NO
---------- ---------- --------- ---------- ------------ ---------- ---------- ---------- ---------- --
      7369 SMITH      CLERK           7902 17-DEC-80           800                    20        1 01
      7369 SMITH      CLERK           7902 17-DEC-80           800                    20        2 02
      7369 SMITH      CLERK           7902 17-DEC-80           800                    20        3 03
      7499 ALLEN      SALESMAN        7698 20-FEB-81          1600        300         30        1 01
      7499 ALLEN      SALESMAN        7698 20-FEB-81          1600        300         30        2 02
      7499 ALLEN      SALESMAN        7698 20-FEB-81          1600        300         30        3 03
      .
      .
      .

42 rows selected.


-- 오라클 9i부터는 dual테이블에 START WITH절 없이 CONNECT BY 구문을 사용하면 두 개의 집합이 자동으로 만들어진다.
select rownum  from dual  connect by level <= 2;

	ROWNUM
----------
         1
         2

-- 이 방법을 사용해 emp 테이블을 복제하는 방법은 아래와 같다.
select *
     from emp a,
     (select rownum  from dual  connect by level <= 2) b
     order by empno
;

     EMPNO ENAME      JOB              MGR HIREDATE            SAL       COMM     DEPTNO     ROWNUM
---------- ---------- --------- ---------- ------------ ---------- ---------- ---------- ----------
      7369 SMITH      CLERK           7902 17-DEC-80           800                    20        1
      7369 SMITH      CLERK           7902 17-DEC-80           800                    20        2
      7499 ALLEN      SALESMAN        7698 20-FEB-81          1600        300         30        2
      7499 ALLEN      SALESMAN        7698 20-FEB-81          1600        300         30        1
      7521 WARD       SALESMAN        7698 22-FEB-81          1250        500         30        1
      7521 WARD       SALESMAN        7698 22-FEB-81          1250        500         30        2
      .
      .
      .
28 rows selected.
```



- 데이터 복제 기법을 활용하면 아래와 같이 단일 SQL로도 부서별 소계를 구할 수 있다.

```sql
break on 부서번호
column 부서번호 format 9999
column 사원번호 format a10
select deptno 부서번호
       , decode(no, 1, to_char(empno), 2, '부서계') 사원번호
       , sum(sal) 급여합, round(avg(sal)) 급여평균
from   emp a, (select rownum no from dual connect by level <= 2)
group by deptno, no, decode(no, 1, to_char(empno), 2, '부서계')
order by 1, 2;


부서번호 사원번호       급여합   급여평균
-------- ---------- ---------- ----------
      10 7782             2450       2450
         7839             5000       5000
         7934             1300       1300
         부서계           8750       2917
      20 7369              800        800
         7566             2975       2975
         7788             3000       3000
         7876             1100       1100
         7902             3000       3000
         부서계          10875       2175
      30 7499             1600       1600
         7521             1250       1250
         7654             1250       1250
         7698             2850       2850
         7844             1500       1500
         7900              950        950
         부서계           9400       1567

17 rows selected.
```



- 이처럼 group by를 잘 구사하면 우리가 원하는 데이터 집합을 자유자재로 가공해 낼 수 있다.
- 아래는 세 개로 복제하고서 총계까지 구하는 사례다.

```sql
column 부서번호 format a10
select decode(no, 3, null, to_char(deptno)) 부서번호
      , decode(no, 1, to_char(empno), 2, '부서계', 3, '총계') 사원번호
      , sum(sal) 급여합, round(avg(sal)) 급여평균
 from   emp a, (select rownum no from dual connect by level <= 3)
 group by decode(no, 3, null, to_char(deptno))
       , no, decode(no, 1, to_char(empno), 2, '부서계', 3, '총계')
order by 1, 2;


부서번호   사원번호       급여합   급여평균
---------- ---------- ---------- ----------
10         7782             2450       2450
           7839             5000       5000
           7934             1300       1300
           부서계           8750       2917
20         7369              800        800
           7566             2975       2975
           7788             3000       3000
           7876             1100       1100
           7902             3000       3000
           부서계          10875       2175
30         7499             1600       1600
           7521             1250       1250
           7654             1250       1250
           7698             2850       2850
           7844             1500       1500
           7900              950        950
           부서계           9400       1567
           총계            29025       2073

18 rows selected.
```



- 표준 ROLLUP 구문을 사용하면 데이터 복제 기법을 쓰지 않고도 아래와 같이 간편하게 소계및 총계를 구할 수 있다.

```sql
break on 부서번호
column 부서번호 format 9999
column 사원번호 format a10
select deptno 부서번호
       , case when grouping(empno) = 1 and grouping(deptno) = 1 then '총계'
              when grouping(empno) = 1 then '부서계'
              else to_char(empno) end  사원번호
       , sum(sal) 급여합, round(avg(sal)) 급여평균
 from   emp
 group by rollup(deptno, empno)
 order by 1, 2;


부서번호 사원번호       급여합   급여평균
-------- ---------- ---------- ----------
      10 7782             2450       2450
         7839             5000       5000
         7934             1300       1300
         부서계           8750       2917
      20 7369              800        800
         7566             2975       2975
         7788             3000       3000
         7876             1100       1100
         7902             3000       3000
         부서계          10875       2175
      30 7499             1600       1600
         7521             1250       1250
         7654             1250       1250
         7698             2850       2850
         7844             1500       1500
         7900              950        950
         부서계           9400       1567
         총계            29025       2073

18 rows selected.
```