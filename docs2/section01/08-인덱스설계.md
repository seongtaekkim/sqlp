# 08. 인덱스설계



## 1) 가장 중요한 두 가지 선택 기준

- 인덱스에 사용할 컬럼을 선택하고, 순서를 정하는 데는 중요한 기준이 두 가지 있다.



**인덱스 선택기준 두가지**

- 조건절에 항상 또는 자주 사용되는 컬럼을 선택한다.
- '='조건으로 자주 조회되는 컬럼들을 앞쪽에 둔다.



## 2) 인덱스 설계는 공식이 아닌 전략과 선택의 문제

- 공식은 기본이 되는 기준이다. 공식만 지키다 보면, 인덱스 개수만 자꾸 늘어간다.
- 인덱스 설계에는 정답이 없다. 그러므로, 인덱스 구성을 왜 그렇게 했는지에 대해 판단근거를 논리적으로 제시할 수 있으면 된다.
- 최소의 인덱스의 개수로 다수의 DML의 성능을 만족시키는 것이 궁극의 목표다.



##### 간단한 설계 예제

- 거래 테이블을 액세스하는 조건절이 아래 4가지만 있다고 가정하면, 어떻게 인덱스를 구성하는 것이 최적일까?
- (고객수:100만명, 상품:10만개, 거래일자의 검색범위는 유동적)

```sql
<검색조건1>
where 고객번호 = 1
and 거래일자 between '20090101'and '20090331'

<검색조건2>
where 상품번호 = 'A'
and 거래일자 between '20090101'and '20090331'

<검색조건3>
where 고객번호 = 1
and 상품번호 = 'A'
and 거래일자 between '20090101'and '20090331'

<검색조건4>
where 거래일자 between '20090101'and '20090331'
```



![스크린샷 2024-04-08 오전 9.54.06](../../img/104.png)



- 스타일 A: 모든 조건절 경우 만큼, 인덱스 만들거야? DML부하도 있고 관리도 힘들고.
- 스타일 B: 조건3일때, X1을 사용하면, 테이블필터링이 발생하나, 고객번호가 워낙 변별력이 좋으니 괜찮겠지? 허나 아주 넓은 거래일자를 범위검색하면 상품번호 필터링때문에 다소 비효율적
- 스타일 C: 그래서\!\! 스타일 B에서 조건3을 비효율을 만회하고자, X1인덱스에 상품번호를 추가하였어..
- 스타일 D: 스타일B와 유사한 전략으로 여기도 조건3의 비효율을 만회하려고, X2인덱스에 고객번호를 추가했는데, 상품번호의 선택도가 고객번호보다 높아 C보다는 인덱스스캔이 많을걸.
- 스타일 E: between 조건 뒤는 거의 인덱스 필터역할만 하므로 둘중하나만 있어도 무방. 그럼 스타일 I랑 동일
- 스타일 F: 4개의 조건에는 그닥 효과없음
- 스타일 G: 검색조건 1,2 에서 인덱스 스캔 비효율.
- 스타일 H: 검색조건 2,4에대한 대비 없고, 검색조건1에서도 인덱스 스캔 비효율큼
- 스타일 I: 변별력이 좋은 고객번호가 조건에 포함되면 X1인덱스를 효과적으로 이용가능, X2의 선두에 거래일자가 약간의 비효율이 있으나 범용적으로 사용하는 컬럼이므로 좋게 평가.
- 스타일 J: 인덱스 활용성이 높으나, 근본적으로 비효율이 있으므로 신중히 고려



##### 효율성 비교분석

- 스타일 A와 I의 설계의 효율 비교

| 스타일A                                                      | 스타일I                                             |
| :----------------------------------------------------------- | :-------------------------------------------------- |
| X1:고객번호+거래일자  X2:상품번호+거래일자  X3:상품번호+고객번호+거래일자  X4:거래일자 | X1:고객번호+거래일자  X2:거래일자+상품번호+고객번호 |



| 조건  | 스타일A                    | 스타일I                                                      | 비고                                            |
| :---- | :------------------------- | :----------------------------------------------------------- | :---------------------------------------------- |
| 조건1 | X1                         | X1                                                           | 두번의 테이블 Random Access                     |
| 조건2 | X2                         | X2-불필요한 상품번호까지 스캔하는 비효율존재                 | 세번의 테이블 Random Access                     |
| 조건3 | X3-단 한건의 Random Access | X1-두번의 테이블액세스, 거래범위가 좁으면 X2를 이용해 불필요한 Random Access를 없애는게 좋을수도 |                                                 |
| 조건4 | X4                         | X2                                                           | 동일한 테이블 Random Access, Range파티션 고려ㄴ |

- 테이블 Random 액세스 측면에서 보면, 스타일I가 조건3에서 약간불리. 하지만 고객번호가 변별력이 워낙 좋으니 큰 차이가 안날 수 있다. 부하가 심하면 X2사용
- 인덱스스캔효율 측면에서 보면, 스타일I가 조건2, 조건3에서 비효율적. 하지만 인덱스 블록에는 하나당 수백개의 레코드가 담기므로 괜찮을것이다.



###### 스캔 효율성 이외의 판단 기준

- 인덱스를 설계할 때는 인덱스 스캔의 효율성 뿐만아니라, 시스템 전체적인 관점에서의 아래와 같은 추가적인 요소들을 고려해야한다.
  - 쿼리수행빈도
  - 업무상 중요도
  - 클러스터링 팩터
  - 데이터량
  - DML부하(=기존 인덱스 개수, 초당 DML 발생량, 자주 갱신되는 컬럼 포함 여부 등)
  - 저장공간
  - 인덱스 관리비용 등



##### 인덱스 설계는 공식이 아닌 전략과 선택의 문제

- 인덱스 설계는 개별 쿼리 성능 뿐만 아니라, 인덱스 개수를 최소화하여 DML부하를 줄이는 것도 목표로 삼아야 한다.
- 그리고 왜 그런 선택을 했는지, 전략적 판단 근거가 무엇인지 답할 수 있어야 한다.
- 실무적으로는 파티션 설계를 먼저 진행하거나, 최소한 인덱스 설계와 병행하는 것이 바람직하다.



##### 인덱스 전략 수립을 위한 훈련

- 고객 테이블에 대해 인덱스 구성전략 수립해보기.

```sql
<쿼리1> - 사용빈도 높음
select * from 고객
where 고객번호 = :no;

<쿼리2>
select * from 고객
where 연령 = :age
and 성별 = :gender
and 이름 like :name || '%';

<쿼리3>
select * from 고객
where 연령 between :age1 and :age2
and 거주지역 = :region
and 등록일 like :rdate || '%';

<쿼리4> - 사용빈도 높음
select /*+ orderd use_nl(b) */ * from 주문 a, 고객 b
where a.거래일자 = :tdate
and a.상품번호 = :good
and a.고객번호 = b.고객번호
and b.거주지역 = :region;
```

 인덱스 구성

- IX01: 고객번호+거주지역(쿼리1, 쿼리4)
- IX02: 연령+거주지역(쿼리2, 쿼리3)